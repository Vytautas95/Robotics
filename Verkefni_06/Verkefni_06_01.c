#pragma config(Sensor, in1,    lineFollowerRIGHT, sensorLineFollower)
#pragma config(Sensor, in2,    lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in3,    lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, dgtl5,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl10, limitSensor,    sensorTouch)
#pragma config(Motor,  port2,           leftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port7,           armMotor,      tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*        Follow a line, pick up an object than turn around and follow same line and finally put the  *|
|*                                    object through a basked                                         *|
\*-----------------------------------------------------------------------------------------------4246-*/


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
int highpow = 26; // Motorspeed when moving the wheels
int nopower = 0; // Stopping the motor
float someDegree = 113.097/31.41; // How far the wheels have to go for 1 degree
float oneDegree = someDegree - 0.5; // fix the distance for one degree
float degree;
void turnright(int degrees) //function for turning right
{
	degree = oneDegree * degrees; // calcualting how many degrees it needs to turn
	while(abs(SensorValue[rightEncoder]) < degree) // While the right encoder is less than distance:
  {
		// spins right around itself
		motor[rightMotor] = -63;		    // Right Motor is run at power level -63
		motor[leftMotor]  = 63;		    // Left Motor is run at power level 63
  }
}
task main()
{
	wait1Msec(10000);
	bool killswitch = false;
	bool reverse = false;
  wait1Msec(2000);          // The program waits for 2000 milliseconds before continuing.

  int threshold = 2550;      /* found by taking a reading on both DARK and LIGHT    */
                            /* surfaces, adding them together, then dividing by 2. */
  while (killswitch == false) // Follow a line unless the button on the robot or controller is pressed
  {
	  while(killswitch == false && reverse == false)
	  {
			if(vexRT[Btn7U] == 1 || SensorValue(touchSensor) == 1)
			{
				killswitch = true;
			}
	    else if(SensorValue(lineFollowerRIGHT) > threshold)
	    {
	      // counter-steer right:
	      motor[leftMotor]  = nopower;
	      motor[rightMotor] = highpow;
	    }
	    // CENTER sensor sees dark:
	    else if(SensorValue(lineFollowerCENTER) > threshold)
	    {
	      // go straight
	      motor[leftMotor]  = highpow;
	      motor[rightMotor] = highpow;
	    }
	    // LEFT sensor sees dark:
	    else if(SensorValue(lineFollowerLEFT) > threshold)
	    {
	      motor[leftMotor]  = highpow;
	      motor[rightMotor] = nopower;
	    }
	    else // When it doesn't see a line, makes it stop, pick up an object than turn around and go into the other loop
	    {
	    	motor[rightMotor] = nopower;
	    	motor[leftMotor] = nopower;
	    	wait1Msec(500);
	    	motor[clawMotor] = -127;
	    	wait1Msec(2000);
	    	motor[clawMotor] = 0;
	    	motor[armMotor] = -64;
	    	wait1Msec(1000);
	    	motor[armMotor] = 0;
	    	SensorValue[rightEncoder]  = 0;    /* null the encoder*/
	    	turnright(170);
	    	motor[rightMotor] = highpow;
	    	motor[leftMotor] = highpow;
	    	wait1Msec(500);
	    	reverse = true;
	  	}
	  }
	  while(killswitch == false && reverse == true) // Same as before just in the end opens claw and therefor drops the object
	  {
	  	if(vexRT[Btn7U] == 1 || SensorValue(touchSensor) == 1)
			{
				killswitch = true;
			}
	    else if(SensorValue(lineFollowerRIGHT) > threshold)
	    {
	      // counter-steer right:
	      motor[leftMotor]  = nopower;
	      motor[rightMotor] = highpow;
	    }
	    // CENTER sensor sees dark:
	    else if(SensorValue(lineFollowerCENTER) > threshold)
	    {
	      // go straight
	      motor[leftMotor]  = highpow;
	      motor[rightMotor] = highpow;
	    }
	    // LEFT sensor sees dark:
	    else if(SensorValue(lineFollowerLEFT) > threshold)
	    {
	      motor[leftMotor]  = highpow;
	      motor[rightMotor] = nopower;
	    }
	    else
	    {
	    	motor[rightMotor] = nopower;
	    	motor[leftMotor] = nopower;
	    	wait1Msec(500);
	    	motor[clawMotor] = 127;
	    	wait1Msec(2000);
	    	motor[clawMotor] = 0;
	    	killswitch = true;
	  	}
		}
	}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
